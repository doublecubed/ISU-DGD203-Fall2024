// Code generated by Claude.ai

using FirstGame;

public class GameMap
{
    #region REFERENCES

    private Game _game;
    private MapLocations _locations;
    
    #endregion
    
    #region VARIABLES

    private const int DefaultWidth = 5;
    private const int DefaultHeight = 5;
    
    private readonly int _width;
    private readonly int _height;
    private Vector2Int _playerPosition;

    #endregion
    
    #region CONSTRUCTOR
    
    public GameMap(Game game, int width, int height, Vector2Int startPosition)
    {
        _game = game;
        
        CheckInputDimensions(ref width, ref height);

        _width = width;
        _height = height;
        
        // Initialize all locations with default values
        _locations = new MapLocations(this);

        // Set initial player position if valid
        if (IsValidPosition(startPosition))
        {
            _playerPosition = startPosition;
        }
        else
        {
            _playerPosition = new Vector2Int() ;
        }
    }
    
    #endregion

    #region METHODS

    private void CheckInputDimensions(ref int width , ref int height)
    {
        if (width <= 0 || height <= 0)
        {
            width = DefaultWidth;
            height = DefaultHeight;
        }
    }
    
    public Vector2Int GetPlayerPosition() => _playerPosition;

    /*
    // The method above does the same thing as this one:
    public (int x, int y) GetPlayerPosition()
    {
        return _playerPosition;
    }
    */

    public bool MovePlayer(Direction direction)
    {
        var newPosition = CalculateNewPosition(direction);
        return SetPlayerPosition(newPosition);
    }

    public bool MovePlayer(Vector2Int targetPosition)
    {
        return SetPlayerPosition(targetPosition);
    }

    private bool SetPlayerPosition(Vector2Int targetPosition)
    {
        if (IsValidPosition(targetPosition))
        {
            _playerPosition = targetPosition;
            return true;
        }
        return false;
    }
    
    private Vector2Int CalculateNewPosition(Direction direction)
    {
        // switch chooses from the possible cases, and then does the code inside.
        // It is a version of if for limited case scenarios
        
        Vector2Int newPosition = new Vector2Int();
        newPosition = _playerPosition;
        
        switch (direction)
        {
            case Direction.North:
                newPosition.Y += 1;
                break;
            case Direction.South:
                newPosition.Y -= 1;
                break;
            case Direction.West:
                newPosition.X -= 1;
                break;
            case Direction.East:
                newPosition.X += 1;
                break;
            default:
                Console.WriteLine("That is not a valid direction");
                break;
        }

        return newPosition;
    }

    private bool IsValidPosition(Vector2Int targetPosition)
    {
        // Check if inside map bounds, if not return false immediately
        bool isWithinMapBounds =  targetPosition.X >= 0 && targetPosition.X < _width && 
               targetPosition.Y >= 0 && targetPosition.Y < _height;
        if (!isWithinMapBounds) return false;

        // Check if the current location exists, and whether it allows moving in the direction
        if (_locations.Locations.TryGetValue(_playerPosition, out MapLocationData mapLocation))
        {
            Console.WriteLine("Location found, processing input");
            Vector2Int currentPosition = mapLocation.Coordinates;
            Vector2Int directionVector = new Vector2Int();
            directionVector.X = targetPosition.X - currentPosition.X;
            directionVector.Y = targetPosition.Y - currentPosition.Y;

            Direction moveDirection = CalculateDirection(directionVector);
            int checkIndex = (int)moveDirection;

            return mapLocation.AllowsTravel[checkIndex];
        }
        
        // if everything else is passed, just return true
        return true;
    }

    public string GetCurrentLocationName()
    {
        // The better way of doing this is presented in the method below
        if (_locations.Locations.ContainsKey(_playerPosition))
        {
            return _locations.Locations[_playerPosition].Name;
        }

        return "the middle of nowhere.";
    }
    
    public string GetCurrentLocationDescription()
    {
        // This is the better way of doing that thing above
        if (_locations.Locations.TryGetValue(_playerPosition, out MapLocationData location))
        {
            return location.Description;
        }

        return "I told you, there is nothing here!";
    }

    public void InteractWithCurrentLocation()
    {
        if (!_locations.Locations.TryGetValue(_playerPosition, out MapLocationData location) 
            || !location.IsInteractable)
        {
            Console.WriteLine("There is nothing to do here");
            return;
        }

        Interaction interaction = location.Interaction;
        interaction.Choose();
    }

    private Direction CalculateDirection(Vector2Int directionVector)
    {
        if (directionVector.X == 1 && directionVector.Y == 0) return Direction.East;
        if (directionVector.X == 0 && directionVector.Y == 1) return Direction.North;
        if (directionVector.X == -1 && directionVector.Y == 0) return Direction.West;
        if (directionVector.X == 0 && directionVector.Y == -1) return Direction.South;
        return Direction.North;
    }
    
    #endregion
}

public enum Direction
{
    East,
    North,
    West,
    South,
    NorthEast,
    NorthWest,
    SouthEast,
    SouthWest,
    Up,
    Down,
    Inside,
    Outside,
    Right,
    Forward,
    Left,
    Back
}

